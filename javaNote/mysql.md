## MVCC
### 定义
对于 读已提交 和 可重复读， 通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，
来控制并发事务访问同一个记录时的行为，这就叫 MVCC(多版本并发控制)。
### Read View 和 快照读 和 当前读 关系
- 快照读的实现是基于 Read View 的
- 当前读与 Read View 无关，它是基于 next-key lock
- 即 快照读的实现是基于MVCC的，而当前读不是
### innodb在可重复读下依然会有幻读发生的原因
先执行普通 SELECT（快照读），然后再执行 UPDATE，可能会发生幻读，因为快照读使用的是 MVCC（多版本并发控制），
不会加锁，导致在 UPDATE 时可能发现新的数据行（幻行）。  
如果只有纯粹的普通 SELECT，或者开始时就执行 UPDATE 加锁，就不会发生幻读了。  
所以本质上来说，是因为mvcc不加锁，导致没有及时的加锁，后面再update上锁的时候就可能已经被其他事务修改了。
## SQL优化
### 为什么避免使用null
- 性能：
  - 索引效率降低，很多数据库引擎处理 NULL 值时无法使用现有索引的优化，甚至可能完全不使用索引。
  - NULL 值查询的开销大，查询中包含 WHERE column IS NULL，数据库需要在处理过程中对所有符合条件的记录进行扫描（全表扫描），而不是利用简单的索引范围查找。
- 复杂性：
  - 无法使用==，必须用is null判断
  - 不同聚合函数处理null有不同规则
  - null和空字符串意义不一样，混用可能会导致困惑
- 数据完整性：
  - null表示数据缺失，会影响完整性
### 具体优化措施：
- 尽量避免全表扫描select *，而是指明需要查询的字段
- 避免使用 > , < , != 等，因为不会走索引
- 避免使用in，因为会走全表扫描，对连续的数据使用between
- 使用exists代替in（in会全表扫描，并将结果加载到内存，而exists查到了就会提前退出）
- 当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新（减少数据库的交互次数）
- 在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现
- 使用连接查询代替子查询（连接查询可以利用索引优化）
- 拆分复杂的大 SQL 为多个小 SQL（可以利用并行计算）