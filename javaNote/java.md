## CPU使用率飙升排查
### 出现原因
- 死循环
- 死锁
- 并行线程过多
- 计算密集型任务多
- 内存不足导致频繁页交换
- 频繁GC
### 排查方案
- 1\. top 命令查看占用率最高的几个进程
```top```

- 2\. 查看12345号进程的线程占用情况（假如最高的是66666号线程）
```top -Hp 12345```

- 3\. 将6666号线程转为16进制（得到0x1046a）
```printf '0x%x\n' 66666```

- 4\. 查看12345号进程中0x1046a线程栈情况
```jstack 12345 | grep 0x1046a -A 20```


## ConcurrentHashMap
### ConcurrentHashMap扩容
在JDK8的源码里面引入了一个ForwardingNode类，采用头插法的方式把当前旧table数组的指定任务范围的数据给迁移到新的数组中，然后
给旧table原位置赋值fwd。直到遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断head节点是否为forwardNode节点，如果是就帮助扩容。
- 在扩容时读写操作如何进行：
- get：如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。 如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时get线程会帮助扩容。 
- put/remove：如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。 


## 垃圾回收
### 哪些是GCRoot
- 栈中的局部变量和方法参数
- 静态字段（静态变量）
- 活动的线程
- JNI 引用
- 常量池（字符串常量池）中的引用
- 类的 Class 对象