## CPU使用率飙升排查
### 出现原因
- 死循环
- 死锁
- 并行线程过多
- 计算密集型任务多
- 内存不足导致频繁页交换
- 频繁GC
### 排查方案
- 1\. top 命令查看占用率最高的几个进程  
```top```

- 2\. 查看12345号进程的所有线程占用情况（如果其中占用最高的是66666号线程）  
```ps -T -p 12345```

- 3\. 将6666号线程转为16进制（得到0x1046a）  
```printf '0x%x\n' 66666```

- 4\. 查看12345号进程中0x1046a线程栈情况  
```jstack 12345 | grep 0x1046a -A 20```

## Full GC 排查
### 产生原因
- （1）内存泄漏场景
  - 程序中存在未正确关闭的资源，如数据库连接、文件流等
  - 大量静态变量或静态集合
  - 使用ThreadLocal但未正确移除，导致内存泄漏
- （2）高并发服务场景
  - 大量对象在短时间内被创建并快速晋升到老年代，导致老年代空间不足
- （3）大对象分配场景
  - 频繁创建大对象或大数组，这些对象直接被分配在老年代
- （4）内存碎片化场景
- （5）显式调用GC场景
- （6）元空间溢出场景
- （7）JVM参数配置不当场景

### 排查步骤
- 1\. 开启并分析GC日志  
```-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:/path/to/gc.log```  
  - 关注点：GC频率、持续时间、内存使用情况、对象晋升情况
- 2\. JVM自带工具
  - jstat：监控JVM的GC情况
  - jmap：生成堆转储文件或查看内存使用情况
  - jstack：生成线程转储，分析线程状态
- 3\. 堆转储 + 第三方工具
  - 堆转储jmap命令
   ```jmap -dump:live,format=b,file=heap.hprof <pid>```
  - JVisualVM：图形化JVM监控工具，可以监控内存、CPU、线程等
  - 堆转储分析要点：
    - 大对象分析
    - 对象实例数分析
    - GC Root分析
    - 对象年龄分析

### JVisualVM定位问题 问题特征
- 看趋势：
  - 老年代曲线是持续上涨不回落（泄露），还是周期性波动（高并发瞬时占用）。
- 看对象类型：
  - 异常单一类型占用大 → 泄露（尤其是集合、ThreadLocalMap）。
  - 大量业务请求对象，生命周期正常 → 高并发。
  - 少量超大数组对象 → 大对象问题。
- 看引用链：用 Show GC Roots 看对象为什么存活：
  - 如果是静态引用链条 → 泄露。 
  - 如果只是业务方法栈里持有 → 并发压力。
- Full GC 后老年代仍无法分配新对象 → 内存碎片。

### 应对策略
- （1）内存泄漏问题：
  - try-with-resources
  - 集合预设合理的初始容量
  - 正确使用ThreadLocal
- （2）高并发服务问题：
  - 调整JVM内存参数（增加年轻代空间，减少对象晋升 | 调整对象晋升年龄阈值）
  - 优化GC策略（G1收集器替代CMS）
  - 优化线程池配置（有界队列，避免任务堆积导致内存溢出）
- （3）大对象分配问题：
  - 优化数据库操作（分页查询，避免一次加载大量数据 | 优化SQL查询，只选择必要的字段）
  - 调整JVM参数（设置大对象直接进入老年代的阈值）
  - 代码层面优化（拆分大对象 | 延迟加载，按需创建）

### JVM参数优化方案
- （1）堆内存配置优化
  - 堆大小、新生代与老年代比例、Survivor空间比例
- （选择合适垃圾回收器）

## ConcurrentHashMap
### ConcurrentHashMap扩容
在JDK8的源码里面引入了一个ForwardingNode类，采用头插法的方式把当前旧table数组的指定任务范围的数据给迁移到新的数组中，然后
给旧table原位置赋值fwd。直到遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断head节点是否为forwardNode节点，如果是就帮助扩容。
- 在扩容时读写操作如何进行：
- get：如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。 如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时get线程会帮助扩容。 
- put/remove：如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。 


## 垃圾回收
### 哪些是GCRoot
- 栈中的局部变量和方法参数
- 静态字段（静态变量）
- 活动的线程
- JNI 引用
- 常量池（字符串常量池）中的引用
- 类的 Class 对象