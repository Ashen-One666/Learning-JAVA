## 栈和队列

## 互相实现

### 232.用栈实现队列
- 思路：使用两个stack模拟队列（stackIn 和 stackOut）。  
  存数据时只要向In中push即可。  
  取数据时，如果Out有数据则优先取Out，如果没有，就将In中的全部数据push到Out中，在从Out顶部取（相当于反转In中的顺序，使先进后出变为先进先出）。

### 225. 用队列实现栈
- 思路：只用一个队列q。  
  存数据时只要向q中add即可。  
  取数据时，将q中前n - 1个元素依此插到队尾，此时队头的元素就是栈顶元素。  
  peek数据时，之前操作和取数据一致，只要在最后把队头的元素再放到队尾就行（复原原先队列的顺序）。

## 用栈解决匹配问题

### 20. 有效的括号
- 思路：用栈实现。为左括号就入栈，为右括号就从栈顶取值，判断是否匹配。

### 1047. 删除字符串中的所有相邻重复项
- 思路：用栈实现。每次入栈前判断和栈顶元素是否相等，相等则pop栈顶，不相等则入栈。

### 71. 简化路径
- 思路：用栈实现。首先将path以"/"分隔（重复的"/"会分隔出空字符串），然后遍历，如果是".."，则弹出栈顶元素，如果不为".."且不为空字符串，则入栈。

## 模拟计算

### 150. 逆波兰表达式求值
- 思路：类似计算器的实现。遇到数字则入栈，遇到符号则从栈中取出2个数字，运算后结果放回栈中

## 单调队列

### 239. 滑动窗口最大值
- 思路1：使用treemap，维护窗口内最大的元素。每次判断、插入和删除时间复杂度均为O(logN)，总复杂度为O(NlogN)。
- 思路2：使用deque，维护一个单调队列，存储窗口中从最大元素开始的递减元素（即有可能成为窗口里最大值的元素）。   
    - 实现方法：  
      每次窗口进入一个元素x，循环判断x是否大于deque的末尾，大于则删去末尾，直至小于等于末尾或deque为空，此时将x插入deque末尾。
      这时的x就是有可能成为窗口里最大值的元素。  
      而对于移出窗口的元素y，如果y等于deque队首，则移除队首，否则不操作。  
      这样deque队首始终就是窗口内的最大元素了。

## 优先队列

### 347. 前 K 个高频元素
- 思路：熟悉优先队列、hashmap、比较器的使用